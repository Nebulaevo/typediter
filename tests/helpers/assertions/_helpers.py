""" Defines helper functions for the assertions module """

from typing import Any, Type, Generator

from typediter.types import TypedIterable_T
from typediter import (
    TypedList_lt, TypedList,
    TypedTuple_lt, TypedTuple,
    TypedSet_lt, TypedSet,
    TypedFrozenset_lt, TypedFrozenset
)

from tests.helpers.types import BuiltinIterableBase_T


# get built-in equivalent from typed iterable

TYPED_ITERABLES_EQUIVALENCY: dict[ Type[TypedIterable_T], Type[BuiltinIterableBase_T] ] = {
    TypedList_lt: list,
    TypedList: list,

    TypedTuple_lt: tuple,
    TypedTuple: tuple,

    TypedSet_lt: set,
    TypedSet: set,

    TypedFrozenset_lt: frozenset,
    TypedFrozenset: frozenset,
}

def get_builtin_equivalent( 
        classe_or_inst: TypedIterable_T | Type[ TypedIterable_T ]
) -> Type[BuiltinIterableBase_T]:
    """ Returns the equivalent built-in iterable class to a typed iterable class or instance 
    
    Parameters
    ----------
    - **classe_or_inst**
        the typed iterable classe instance 
        for which we want to find the built-in iterable class it is based on
    """
    
    if isinstance( classe_or_inst, type ):
        cls = classe_or_inst
    else:
        cls = type(classe_or_inst)

    return TYPED_ITERABLES_EQUIVALENCY[ cls ]

# extraction of test value helper

def extract_test_values( samples:list, index:int ) -> tuple[ Any, Any, Any ]:
    """ Helper function returning 3 duplicates of a value in a sample list 

    Aimed at providing a consistent handling of sample values.
    That function ensures that, in case the value is a generator, 
    it is replaced in the original sample list by a fresh, unused generator.

    (i) when the sample was a generator it was adding a lot of mess, 
    because of the fact it could only be used once, 
    and we needed to duplicate it, and make sure the version in the 
    samples list was replaced as well.
    So to reduce the mess of having to handle the generator case in the assertions helpers,
    we consistantly return 3 versions of the value for every sample value.

    Parameters
    ----------
    - **samples**
        sample list generated by a TestSamples instance
    
    - **index**
        the index of the sample we want to extract
        
    Returns
    -------
    3 values identical to the one found in the samples list,
    this way we always used different variable for:
    - typed iterable operation
    - built-in equivalent operation (if needed)
    - failure message
    """
    
    value = samples[index]
    if isinstance( value, Generator ):
        tpl = tuple( value )
        samples[index] = _as_gen( tpl )
        return _as_gen(tpl), _as_gen(tpl), _as_gen(tpl)

    return value, value, value

def extract_star_args_test_values( samples:list ) -> tuple[list, list, list]:
    """ Helper function returning 3 duplicate of the samples list

    Aimed at providing a consistent handling of sample values.
    The aim is to safely handle the eventual generators included in the samples list.
    We duplicate each element from the list using 'extract_test_values',
    so that if it encounters a generator, it safely returns 3 copies of it, 
    and replaces the generator in the samples list by a fresh unused one.
    
    (i) used for testing *args operations
    
    Parameters
    ----------
    - **samples**
        sample list generated by a TestSamples instance
    
    Returns
    -------
    3 copies of the given samples list,
    this way we always used different one for:
    - typed iterable operation
    - built-in equivalent operation (if needed)
    - failure message
    """
    samples_A = []
    samples_B = []
    samples_C = []

    for index in range( len(samples) ):
        value_A, value_B, value_C = extract_test_values( samples, index )
        samples_A.append( value_A )
        samples_B.append( value_B )
        samples_C.append( value_C )

    return samples_A, samples_B, samples_C

def _as_gen( tpl:tuple ) -> Generator:
    """ private helper returning a generator """
    return (i for i in tpl)
